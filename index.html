<!DOCTYPE html>
<html lang="te">
<head>
┬а ┬а <meta charset="UTF-8" />
┬а ┬а <meta name="viewport" content="width=device-width, initial-scale=1.0" />
┬а ┬а <title>Mantra OCR </title>
┬а ┬а <link rel="preconnect" href="https://fonts.googleapis.com" />
┬а ┬а <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
┬а ┬а <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Telugu:wght@400;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet" />
┬а ┬а <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5.0.0/dist/tesseract.min.js"></script>
<link rel="stylesheet" href="styles.css" />

</head>
<body>
┬а ┬а <div class="main-container">
┬а ┬а ┬а ┬а <h1>р░Ер░Хр▒Нр░╖р░░ р░╕р░╛р░зр░и</h1>
┬а ┬а ┬а ┬а <div class="status info" id="status">р░ор▒Кр░жр░▓р▒Б р░кр▒Жр░Яр▒Нр░Яр░бр░╛р░ир░┐р░Хр░┐ р░Тр░Х р░лр▒Лр░Яр▒Лр░ир▒Б р░Ер░кр▒НтАМр░▓р▒Лр░бр▒Н р░Ър▒Зр░пр░Вр░бр░┐</div>
┬а ┬а ┬а ┬а <div class="section" id="ocrSection">
┬а ┬а ┬а ┬а ┬а ┬а <h2>1. р░Ър░┐р░др▒Нр░░р░В р░ир▒Бр░Вр░бр░┐</h2>
┬а ┬а ┬а ┬а ┬а ┬а <div class="flex-container">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div class="file-input-wrapper">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <button class="button" id="uploadBtn">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а р░Ър░┐р░др▒Нр░░р░╛р░ир▒Нр░ир░┐ р░Ер░кр▒НтАМр░▓р▒Лр░бр▒Н р░Ър▒Зр░пр░Вр░бр░┐
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <input type="file" id="imageInput" class="file-input" accept="image/*" />
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а </button>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <button class="button" id="btnOcr" disabled>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬аOCRр░ир▒Б р░кр▒Нр░░р░╛р░░р░Вр░нр░┐р░Вр░Ър░Вр░бр░┐
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <span id="ocrSpinner" class="spinner"></span>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а </button>
┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а ┬а ┬а <img id="preview" alt="Uploaded Image" />
┬а ┬а ┬а ┬а ┬а ┬а <div style="margin-top: 1.5rem; text-align: left;">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <label for="ocrText">OCR р░лр░▓р░┐р░др░В (р░╕р░╡р░░р░┐р░Вр░Ър░Вр░бр░┐ & р░кр░┐р░Ър▒НтАМр░▓р░ир▒Б р░Чр▒Бр░░р▒Нр░др░┐р░Вр░Ър░Вр░бр░┐)</label>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <textarea id="ocrText" placeholder="OCR result will appear here"></textarea>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div class="pitch-buttons">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <button class="button secondary-btn" id="btnPitchHigh">High Pitch (р░Йр░жр░╛р░др▒Нр░др░В) ЁЯФ╝</button>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <button class="button secondary-btn" id="btnPitchLow">Low Pitch (р░Ер░ир▒Бр░жр░╛р░др▒Нр░др░В) ЁЯФ╜</button>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <button class="button secondary-btn" id="btnClear">р░Ер░ир▒Нр░ир░┐ р░Хр▒Нр░▓р░┐р░пр░░р▒Н р░Ър▒Зр░пр░Вр░бр░┐ ЁЯЧСя╕П</button>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а ┬а ┬а <div style="margin-top: 2rem;">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <label for="mantraTitle">р░ор░Вр░др▒Нр░░р░В р░╢р▒Ар░░р▒Нр░╖р░┐р░Х:</label>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <input type="text" id="mantraTitle" placeholder="e.g., SriGayatriMantra" />
┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а ┬а ┬а <div style="margin-top: 1rem;">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <label for="mantraDescription">р░╡р░┐р░╡р░░р░г :</label>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <textarea id="mantraDescription" style="min-height: 80px;" placeholder="р░ор░Вр░др▒Нр░░р░В р░пр▒Кр░Хр▒Нр░Х р░╕р░Вр░Хр▒Нр░╖р░┐р░кр▒Нр░д р░╡р░┐р░╡р░░р░г"></textarea>
┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а ┬а ┬а <div class="flex-container">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <button class="button" id="btnSaveMantra">р░Хр▒Кр░др▒Нр░д р░ор░Вр░др▒Нр░░р░╛р░ир▒Нр░ир░┐ р░╕р▒Зр░╡р▒Н р░Ър▒Зр░пр░Вр░бр░┐ ┬атЬи</button>
┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а <div class="section" id="viewMantraSection">
┬а ┬а ┬а ┬а ┬а ┬а <h2>2. р░ор░Вр░др▒Нр░░р░╛р░▓р░ир▒Б р░╡р▒Ар░Хр▒Нр░╖р░┐р░Вр░Ър░Вр░бр░┐ & р░╕р░╡р░░р░┐р░Вр░Ър░Вр░бр░┐</h2>
┬а ┬а ┬а ┬а ┬а ┬а <p style="color: var(--light-text-color);">р░ор░Вр░др▒Нр░░р░В р░Хр░Вр░Яр▒Жр░Вр░Яр▒НтАМр░ир▒Б р░╡р▒Ар░Хр▒Нр░╖р░┐р░Вр░Ър░бр░╛р░ир░┐р░Хр░┐ р░▓р▒Зр░жр░╛ р░кр░┐р░Ър▒НтАМр░▓р░ир▒Б р░Чр▒Бр░░р▒Нр░др░┐р░Вр░Ър░┐ р░╕р░╡р░░р░┐р░Вр░Ър░бр░╛р░ир░┐р░Хр░┐ р░Тр░Х р░ор░Вр░др▒Нр░░р░╛р░ир▒Нр░ир░┐ р░Ор░Вр░Ър▒Бр░Хр▒Лр░Вр░бр░┐.</p>
┬а ┬а ┬а ┬а ┬а ┬а <div class="tab-container" id="tabContainer"></div>
┬а ┬а ┬а ┬а ┬а ┬а <div class="mantra-card" id="mantraDisplayCard">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div id="mantraTitleDisplay"><h3></h3></div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div id="mantraDescriptionDisplay"><p></p></div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div id="mantraContentDisplay" class="pitch-display">р░жр░╛р░ир░┐ р░Хр░Вр░Яр▒Жр░Вр░Яр▒НтАМр░ир▒Б р░Ър▒Вр░бр░Яр░╛р░ир░┐р░Хр░┐ р░Тр░Х р░ор░Вр░др▒Нр░░р░В р░Яр▒Нр░пр░╛р░мр▒НтАМр░ир▒Б р░Ор░Вр░Ър▒Бр░Хр▒Лр░Вр░бр░┐</div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div class="flex-container">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <button class="button secondary-btn" id="btnEditMantra" disabled>р░ор░Вр░др▒Нр░░р░╛р░ир▒Нр░ир░┐ р░╕р░╡р░░р░┐р░Вр░Ър░Вр░бр░┐</button>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <button class="button" id="btnDownloadMantra">JSONр░ир▒Б р░бр▒Мр░ир▒НтАМр░▓р▒Лр░бр▒Н р░Ър▒Зр░пр░Вр░бр░┐</button>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а </div>
┬а ┬а </div>
┬а ┬а <script>
┬а ┬а ┬а ┬а let ritualsMantras = JSON.parse(localStorage.getItem('ritualsMantras')) || {
┬а ┬а ┬а ┬а ┬а ┬а /* your initial mantra data as per your code */
┬а ┬а ┬а ┬а };
┬а ┬а ┬а ┬а const statusElement = document.getElementById('status');
┬а ┬а ┬а ┬а const imageInput = document.getElementById('imageInput');
┬а ┬а ┬а ┬а const preview = document.getElementById('preview');
┬а ┬а ┬а ┬а const btnOcr = document.getElementById('btnOcr');
┬а ┬а ┬а ┬а const ocrSpinner = document.getElementById('ocrSpinner');
┬а ┬а ┬а ┬а const ocrTextarea = document.getElementById('ocrText');
┬а ┬а ┬а ┬а const btnPitchHigh = document.getElementById('btnPitchHigh');
┬а ┬а ┬а ┬а const btnPitchLow = document.getElementById('btnPitchLow');
┬а ┬а ┬а ┬а const btnClear = document.getElementById('btnClear');
┬а ┬а ┬а ┬а const mantraTitleInput = document.getElementById('mantraTitle');
┬а ┬а ┬а ┬а const mantraDescriptionInput = document.getElementById('mantraDescription');
┬а ┬а ┬а ┬а const btnSaveMantra = document.getElementById('btnSaveMantra');
┬а ┬а ┬а ┬а const tabContainer = document.getElementById('tabContainer');
┬а ┬а ┬а ┬а const mantraTitleDisplay = document.getElementById('mantraTitleDisplay');
┬а ┬а ┬а ┬а const mantraDescriptionDisplay = document.getElementById('mantraDescriptionDisplay');
┬а ┬а ┬а ┬а const mantraContentDisplay = document.getElementById('mantraContentDisplay');
┬а ┬а ┬а ┬а const btnEditMantra = document.getElementById('btnEditMantra');
┬а ┬а ┬а ┬а const btnDownloadMantra = document.getElementById('btnDownloadMantra');
┬а ┬а ┬а ┬а let worker;
┬а ┬а ┬а ┬а let currentFile = null;
┬а ┬а ┬а ┬а let pitchMarks = [];
┬а ┬а ┬а ┬а let currentMantraKey = null;

┬а ┬а ┬а ┬а function updateStatus(message, type = 'info') {
┬а ┬а ┬а ┬а ┬а ┬а statusElement.textContent = message;
┬а ┬а ┬а ┬а ┬а ┬а statusElement.className = `status ${type}`;
┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а async function initWorker() {
┬а ┬а ┬а ┬а ┬а ┬а updateStatus("Initializing OCR engine...", 'info');
┬а ┬а ┬а ┬а ┬а ┬а try {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а worker = await Tesseract.createWorker({
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а langPath: "https://cdn.jsdelivr.net/npm/tessdata@4.0.0"
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а await worker.load();
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а await worker.loadLanguage("tel");
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а await worker.initialize("tel");
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а worker.setLogger(m => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (m.status === "recognizing text") {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а updateStatus(`Recognizing text: ${(m.progress * 100).toFixed(2)}%`, 'info');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а updateStatus("OCR engine ready. Upload an image to start.", 'success');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а renderMantraTabs();
┬а ┬а ┬а ┬а ┬а ┬а } catch (error) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а console.error("OCR initialization error:", error);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а updateStatus("Failed to initialize OCR engine.", 'error');
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а initWorker();

┬а ┬а ┬а ┬а imageInput.addEventListener('change', () => {
┬а ┬а ┬а ┬а ┬а ┬а if (imageInput.files.length === 0) return;
┬а ┬а ┬а ┬а ┬а ┬а currentFile = imageInput.files[0];
┬а ┬а ┬а ┬а ┬а ┬а preview.src = URL.createObjectURL(currentFile);
┬а ┬а ┬а ┬а ┬а ┬а preview.style.display = 'block';
┬а ┬а ┬а ┬а ┬а ┬а updateStatus("Image loaded. Click 'Start OCR' to process.", 'info');
┬а ┬а ┬а ┬а ┬а ┬а btnOcr.disabled = false;
┬а ┬а ┬а ┬а ┬а ┬а ocrTextarea.value = "";
┬а ┬а ┬а ┬а ┬а ┬а pitchMarks = [];
┬а ┬а ┬а ┬а });

┬а ┬а ┬а ┬а btnOcr.addEventListener('click', async () => {
┬а ┬а ┬а ┬а ┬а ┬а if (!currentFile || !worker) return;
┬а ┬а ┬а ┬а ┬а ┬а btnOcr.disabled = true;
┬а ┬а ┬а ┬а ┬а ┬а ocrSpinner.style.display = 'inline-block';
┬а ┬а ┬а ┬а ┬а ┬а updateStatus("Performing OCR...", 'info');
┬а ┬а ┬а ┬а ┬а ┬а try {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const { data } = await worker.recognize(currentFile, 'tel');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const sanitizedText = data.text.replace(/[\u030D\u0323]/g, '').trim();
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ocrTextarea.value = sanitizedText;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const segmenter = new Intl.Segmenter('te', { granularity: 'grapheme' });
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const segments = Array.from(segmenter.segment(sanitizedText));
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а pitchMarks = Array(segments.length).fill('none');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а updateStatus("OCR complete. Select text and click a pitch button.", 'success');
┬а ┬а ┬а ┬а ┬а ┬а } catch (error) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а updateStatus("An error occurred during OCR.", 'error');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а console.error("OCR Error:", error);
┬а ┬а ┬а ┬а ┬а ┬а } finally {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а btnOcr.disabled = false;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ocrSpinner.style.display = 'none';
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а });

┬а ┬а ┬а ┬а function getGraphemeIndices(text, startIndex, endIndex) {
┬а ┬а ┬а ┬а ┬а ┬а const segmenter = new Intl.Segmenter('te', { granularity: 'grapheme' });
┬а ┬а ┬а ┬а ┬а ┬а const segments = Array.from(segmenter.segment(text));
┬а ┬а ┬а ┬а ┬а ┬а let indices = [];
┬а ┬а ┬а ┬а ┬а ┬а let charIndex = 0;
┬а ┬а ┬а ┬а ┬а ┬а for (let i = 0; i < segments.length; i++) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const seg = segments[i].segment;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const segmentEndIndex = charIndex + seg.length;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (segmentEndIndex > startIndex && charIndex < endIndex) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а indices.push(i);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а charIndex = segmentEndIndex;
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а return indices;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а function preparePitches(pitchType) {
┬а ┬а ┬а ┬а ┬а ┬а const fullText = ocrTextarea.value;
┬а ┬а ┬а ┬а ┬а ┬а const startIndex = ocrTextarea.selectionStart;
┬а ┬а ┬а ┬а ┬а ┬а const endIndex = ocrTextarea.selectionEnd;
┬а ┬а ┬а ┬а ┬а ┬а if (startIndex === endIndex) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а alert("Please select some text in the OCR Output box first.");
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а return;
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а const selectedGraphemeIndices = getGraphemeIndices(fullText, startIndex, endIndex);
┬а ┬а ┬а ┬а ┬а ┬а if (selectedGraphemeIndices.length === 0) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а alert("Please select some text in the OCR Output box first.");
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а return;
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а selectedGraphemeIndices.forEach(index => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а pitchMarks[index] = pitchType;
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а updateStatus(`Pitches marked. You can now save the mantra or edit the text.`, 'info');
┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а btnPitchHigh.addEventListener('click', () => preparePitches('high'));
┬а ┬а ┬а ┬а btnPitchLow.addEventListener('click', () => preparePitches('low'));
┬а ┬а ┬а ┬а btnClear.addEventListener('click', () => {
┬а ┬а ┬а ┬а ┬а ┬а ocrTextarea.value = '';
┬а ┬а ┬а ┬а ┬а ┬а imageInput.value = '';
┬а ┬а ┬а ┬а ┬а ┬а preview.style.display = 'none';
┬а ┬а ┬а ┬а ┬а ┬а btnOcr.disabled = true;
┬а ┬а ┬а ┬а ┬а ┬а pitchMarks = [];
┬а ┬а ┬а ┬а ┬а ┬а mantraTitleInput.value = '';
┬а ┬а ┬а ┬а ┬а ┬а mantraDescriptionInput.value = '';
┬а ┬а ┬а ┬а ┬а ┬а updateStatus('All OCR content cleared. Upload an image to begin.', 'info');
┬а ┬а ┬а ┬а ┬а ┬а btnSaveMantra.textContent = 'Save New Mantra тЬи';
┬а ┬а ┬а ┬а ┬а ┬а currentMantraKey = null;
┬а ┬а ┬а ┬а });

┬а ┬а ┬а ┬а btnSaveMantra.addEventListener('click', () => {
┬а ┬а ┬а ┬а ┬а ┬а const title = mantraTitleInput.value.trim();
┬а ┬а ┬а ┬а ┬а ┬а const description = mantraDescriptionInput.value.trim();
┬а ┬а ┬а ┬а ┬а ┬а const fullText = ocrTextarea.value;
┬а ┬а ┬а ┬а ┬а ┬а if (!title) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а alert('Please provide a unique title.');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а return;
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а const newKey = title.replace(/\s+/g, '');
┬а ┬а ┬а ┬а ┬а ┬а if (newKey !== currentMantraKey && ritualsMantras.hasOwnProperty(newKey)) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а alert(`The title "${title}" already exists. Please choose a unique title.`);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а return;
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а if (fullText.trim().length === 0) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а alert('OCR output is empty. Please run OCR and mark text before saving.');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а return;
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а const segmenter = new Intl.Segmenter('te', { granularity: 'grapheme' });
┬а ┬а ┬а ┬а ┬а ┬а const segments = Array.from(segmenter.segment(fullText));
┬а ┬а ┬а ┬а ┬а ┬а let mantraInstructions = [];
┬а ┬а ┬а ┬а ┬а ┬а let currentLine = [];
┬а ┬а ┬а ┬а ┬а ┬а segments.forEach((seg, index) => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const char = seg.segment;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const pitch = pitchMarks[index];
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (char.includes('\n')) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (currentLine.length > 0) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а mantraInstructions.push(currentLine);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а currentLine = [];
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а return;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а let syllable = { char: char };
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (pitch && pitch !== 'none') {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а syllable.pitch = pitch;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а currentLine.push(syllable);
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а if (currentLine.length > 0) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а mantraInstructions.push(currentLine);
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а const newMantra = {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а title: title,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а description: description,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а instructions: [{
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а mantra: mantraInstructions
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }]
┬а ┬а ┬а ┬а ┬а ┬а };
┬а ┬а ┬а ┬а ┬а ┬а if (currentMantraKey && currentMantraKey !== newKey) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а delete ritualsMantras[currentMantraKey];
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а ritualsMantras[newKey] = newMantra;
┬а ┬а ┬а ┬а ┬а ┬а currentMantraKey = newKey;
┬а ┬а ┬а ┬а ┬а ┬а localStorage.setItem('ritualsMantras', JSON.stringify(ritualsMantras));
┬а ┬а ┬а ┬а ┬а ┬а updateStatus(`Mantra "${title}" has been saved. You can now view it in the tabs below.`, 'success');
┬а ┬а ┬а ┬а ┬а ┬а renderMantraTabs();
┬а ┬а ┬а ┬а ┬а ┬а loadMantra(newKey);
┬а ┬а ┬а ┬а ┬а ┬а mantraTitleInput.value = '';
┬а ┬а ┬а ┬а ┬а ┬а mantraDescriptionInput.value = '';
┬а ┬а ┬а ┬а ┬а ┬а btnSaveMantra.textContent = 'Save New Mantra тЬи';
┬а ┬а ┬а ┬а });

┬а ┬а ┬а ┬а function renderMantraTabs() {
┬а ┬а ┬а ┬а ┬а ┬а tabContainer.innerHTML = '';
┬а ┬а ┬а ┬а ┬а ┬а for (const key in ritualsMantras) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (ritualsMantras.hasOwnProperty(key)) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const mantra = ritualsMantras[key];
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const tabButton = document.createElement('button');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а tabButton.className = 'tab-button';
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а tabButton.setAttribute('data-key', key);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const titleSpan = document.createElement('span');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а titleSpan.textContent = mantra.title;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а tabButton.appendChild(titleSpan);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const deleteBtn = document.createElement('button');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а deleteBtn.textContent = 'X';
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а deleteBtn.className = 'delete-btn';
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а deleteBtn.setAttribute('title', 'Delete Mantra');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а deleteBtn.addEventListener('click', (event) => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а event.stopPropagation();
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (confirm(`Are you sure you want to delete the mantra "${mantra.title}"?`)) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а delete ritualsMantras[key];
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а localStorage.setItem('ritualsMantras', JSON.stringify(ritualsMantras));
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а updateStatus(`Mantra "${mantra.title}" has been deleted.`, 'success');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а renderMantraTabs();
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (currentMantraKey === key) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а mantraContentDisplay.innerHTML = "Select a mantra tab to view its content.";
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а mantraTitleDisplay.innerHTML = `<h3></h3>`;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а mantraDescriptionDisplay.innerHTML = `<p></p>`;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а btnEditMantra.disabled = true;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а currentMantraKey = null;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а btnSaveMantra.textContent = 'Save New Mantra тЬи';
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а mantraTitleInput.value = "";
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а mantraDescriptionInput.value = "";
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ocrTextarea.value = "";
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а tabButton.appendChild(deleteBtn);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а tabButton.addEventListener('click', (event) => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а event.currentTarget.classList.add('active');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а loadMantra(event.currentTarget.getAttribute('data-key'));
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а btnEditMantra.disabled = false;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а tabContainer.appendChild(tabButton);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а function loadMantra(mantraKey) {
┬а ┬а ┬а ┬а ┬а ┬а const ritual = ritualsMantras[mantraKey];
┬а ┬а ┬а ┬а ┬а ┬а if (!ritual) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а updateStatus(`Mantra "${mantraKey}" not found.`, 'error');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а return;
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а currentMantraKey = mantraKey;
┬а ┬а ┬а ┬а ┬а ┬а const hasPitchMarks = ritual.instructions.some(instruction =>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а Array.isArray(instruction.mantra) && instruction.mantra.some(line => line.some(syl => syl.pitch))
┬а ┬а ┬а ┬а ┬а ┬а );
┬а ┬а ┬а ┬а ┬а ┬а btnEditMantra.disabled = !hasPitchMarks;
┬а ┬а ┬а ┬а ┬а ┬а mantraTitleDisplay.innerHTML = `<h3>${ritual.title}</h3>`;
┬а ┬а ┬а ┬а ┬а ┬а mantraDescriptionDisplay.innerHTML = `<p>${ritual.description}</p>`;
┬а ┬а ┬а ┬а ┬а ┬а let outputHtml = '';
┬а ┬а ┬а ┬а ┬а ┬а ritual.instructions.forEach(instruction => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (typeof instruction.mantra === 'string') {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а outputHtml += `<p style="font-family: 'Noto Sans Telugu', serif; font-size: 1.25rem;">${instruction.mantra}</p>`;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а } else if (Array.isArray(instruction.mantra)) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а instruction.mantra.forEach(line => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а let lineHtml = '';
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а line.forEach(syllable => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а let pitchClass = '';
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (syllable.pitch) pitchClass = ` ${syllable.pitch}`;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а lineHtml += `<span class="pitch-marked-char${pitchClass}">${syllable.char}</span>`;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а outputHtml += `<p style="margin: 0; padding: 0;">${lineHtml}</p>`;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а mantraContentDisplay.innerHTML = outputHtml;
┬а ┬а ┬а ┬а ┬а ┬а updateStatus(`"${ritual.title}" mantra loaded successfully.`, 'success');
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а btnEditMantra.addEventListener('click', () => {
┬а ┬а ┬а ┬а ┬а ┬а if (!currentMantraKey) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а alert("Please select a mantra to edit first.");
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а return;
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а const mantraToEdit = ritualsMantras[currentMantraKey];
┬а ┬а ┬а ┬а ┬а ┬а mantraTitleInput.value = mantraToEdit.title;
┬а ┬а ┬а ┬а ┬а ┬а mantraDescriptionInput.value = mantraToEdit.description;
┬а ┬а ┬а ┬а ┬а ┬а let fullText = "";
┬а ┬а ┬а ┬а ┬а ┬а let newPitchMarks = [];
┬а ┬а ┬а ┬а ┬а ┬а mantraToEdit.instructions.forEach(instruction => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (typeof instruction.mantra === 'string') {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а fullText += instruction.mantra;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а } else if (Array.isArray(instruction.mantra)) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а instruction.mantra.forEach(line => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а line.forEach(syllable => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а fullText += syllable.char;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а newPitchMarks.push(syllable.pitch || 'none');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а fullText += "\n";
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а ocrTextarea.value = fullText.trim();
┬а ┬а ┬а ┬а ┬а ┬а pitchMarks = newPitchMarks;
┬а ┬а ┬а ┬а ┬а ┬а updateStatus(`Editing "${mantraToEdit.title}". Make changes and click 'Save Mantra' to update.`, 'info');
┬а ┬а ┬а ┬а ┬а ┬а btnSaveMantra.textContent = 'Save Mantra';
┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('ocrSection').scrollIntoView({ behavior: 'smooth' });
┬а ┬а ┬а ┬а ┬а ┬а mantraTitleInput.focus();
┬а ┬а ┬а ┬а });

┬а ┬а ┬а ┬а btnDownloadMantra.addEventListener('click', () => {
┬а ┬а ┬а ┬а ┬а ┬а const jsonData = JSON.stringify(ritualsMantras, null, 2);
┬а ┬а ┬а ┬а ┬а ┬а const blob = new Blob([jsonData], { type: 'application/json' });
┬а ┬а ┬а ┬а ┬а ┬а const url = URL.createObjectURL(blob);
┬а ┬а ┬а ┬а ┬а ┬а const a = document.createElement('a');
┬а ┬а ┬а ┬а ┬а ┬а a.href = url;
┬а ┬а ┬а ┬а ┬а ┬а a.download = 'ritualsMantras.json';
┬а ┬а ┬а ┬а ┬а ┬а document.body.appendChild(a);
┬а ┬а ┬а ┬а ┬а ┬а a.click();
┬а ┬а ┬а ┬а ┬а ┬а document.body.removeChild(a);
┬а ┬а ┬а ┬а ┬а ┬а URL.revokeObjectURL(url);
┬а ┬а ┬а ┬а ┬а ┬а updateStatus('Mantra data downloaded successfully.', 'success');
┬а ┬а ┬а ┬а });
┬а ┬а </script>
</body>
</html>
